---
title: 'R04: Phylogenetic corrected Correlations'
author: "Anna Krystalli"
date: "25 February 2016"
output: html_document
---

## First stage: matching tree taxonomy to data taxonomy

### Trees

After consulting Gavin I am using the Mayar corrected, Stage 2 Hackett decisive trees, which I accessed [here](http://litoria.eeb.yale.edu/bird-tree/archives/Stage2_MayrAll_decisive/CombinedTrees/) and I randomly selected [set 10](http://litoria.eeb.yale.edu/bird-tree/archives/Stage2_MayrAll_decisive/CombinedTrees/Stage2_MayrAll_Hackett_set10_decisive.zip). I then just focused on the first tree in the set but obviously our final analysis could be replicated across many trees to get an estimate of uncertainty.

### Matching

The protocol followed is the same used for matching **`D1`** to **`D0`** data and the species in **`D0`** were used to produce the species list to match to. During the process, a number of species in **`D0`** were identified as extinct and removed from the dataset. Also a couple of data points in **`D0`** with invalid data were identified and also removed. This step has now been incorporated into the initial **`D0`** processing stage.

```{r, eval=FALSE}

  D0 <- D0[!D0$species == "Conuropsis_carolinensis",] #species extinct
  D0 <- D0[!D0$species == "Podilymbus_gigas",] #species extinct
  D0 <- D0[!D0$species == "Xenicus_longipes",] #species extinct
  D0 <- D0[!D0$species == "Ectopistes_migratorius",] #species extinct
  D0 <- D0[!D0$species == "Pezophaps_solitaria",] #species extinct
  D0 <- D0[!D0$species == "Pinguinus_impennis",] #species extinct
  D0 <- D0[!D0$species == "Porphyrio_albus",] #species extinct

  # correct data errors:
  D0 <- D0[!(D0$species == "Phasianus_colchicus" & D0$var == "fecundity"),]
  D0 <- D0[!(D0$species == "Passer_domesticus" & D0$var == "habitat"),]

```

<br>


A number of species in the data are actually matched to the same species on the tree. The **`species`** column represents names in the dataset while **`synonyms`** represent names in the tree. You may want to inspect the **`species`** column in particular. These species are all present in the **`D0`** and some of them appear to be synonyms themselves (ie duplicates internal to the dataset). The matching procedure resulted in a lookup dataframe (**`match.dat`**) allowing the translation of `data` species names to `tree` species names


```{r, echo=FALSE, message=F, warning=F}
  require(knitr)
  require(plotly)
  
  codewd <- "~/Documents/worflows/bird_trait_networks/"
  datawd <- "~/"
  output.folder <- "/Users/Anna/Google Drive/bird trait networks/outputs/"
  input.folder <- "/Users/Anna/Google Drive/bird trait networks/inputs/data/"

  load(file = paste(input.folder, "r data/match data/tree m.RData", sep = ""))
  
  dup.dat <- m$data[m$data$synonyms %in% m$data$synonyms[m$data$data.status == "duplicate"],]
  dup.dat <- dup.dat[order(dup.dat$synonyms),]
  kable(dup.dat, row.names = F)
 
  
load(file = paste(input.folder, "tree/phylomat.RData", sep = ""))
  
```



## Second stage: comparing the two phylogenetic correction methods

I've translated much of the initial code you supplied into function and compiled it all into a larger function to run the comparison between the two methods. The code for the functions and the workflow are supplied in **Appendix 2** for you to inspect. The first method using the inverted matrix of predicted trait covariances (let me know if I am interpretting this correctly) works smoothly. The only time consuming step is inverting the var/covar matrix (about 15 mins) but that only needs to be done once. In fact, because it does not change, I have just saved a copy so I can just load it into any analysis.

The pgls method on the other hand failed at times, citing ***computational singularity in the system***. Of the **8966** variable combinations (with >30 shared data points) tested, the **pgls method failed in 92 cases**


**NOTE** I cave not changed the default settings of the **`vcv`** or **`pgls`** functions but they both default to Brownian model of trait evolution as far as I understand. The results of the comparisons can be found in this [csv](https://drive.google.com/open?id=0B9BMeZ9H2nRxRHo3UXNnWlQ4NEU) 


```{r, echo=FALSE, message=F, warning=F}

makeTransparent<-function(someColor, alpha=100)
{
  newColor<-col2rgb(someColor)
  apply(newColor, 2, function(curcoldata){rgb(red=curcoldata[1], green=curcoldata[2],
                                              blue=curcoldata[3],alpha=alpha, maxColorValue=255)})
}

metadata <- read.csv(paste(input.folder, "metadata/","metadata.csv", sep = ""), 
                     stringsAsFactors = F, fileEncoding = "mac") %>% 
  apply(2, FUN = trimws) %>% data.frame(stringsAsFactors = F)


res <- read.csv(paste(input.folder, "r data/phylocor comps.csv", sep = ""), stringsAsFactors = F)
res.i <- res[complete.cases(res),]

col = makeTransparent("grey", 60)
text <- paste(res.i$var1, "-", res.i$var2)
plot(phylocor1 ~ phylocor2, data = res.i, pch = 21, bg = col, col = col,
     xlim = c(-1,1), ylim = c(-1,1))
abline(0,1)


plot(phylocor1 ~ cor, data = res.i, pch = 21, bg = col, col = col,
     xlim = c(-1,1), ylim = c(-1,1))
abline(0,1)

plot(phylocor2 ~ cor, data = res.i, pch = 21, bg = col, col = col,
     xlim = c(-1,1), ylim = c(-1,1))
abline(0,1)




```

### Relationship to data availability

Data availability does not seem to be the driver of the differences in the two methods

```{r, echo=FALSE, message=F, warning=F}

plot(abs(res.i$phylocor1 - res.i$phylocor2) ~ res.i$n, pch = 21, bg = col, col = col, xlab = "data points available", ylab = "abs difference between phylocor1 & phylocor2")

```

<br>
<br>

***

## APPENDIX 1

#### Top 400 most strongly related variables (absolute values) according to phylocor1

```{r, echo=FALSE, message=F, warning=F}

kable(res[order(abs(res$phylocor1), decreasing = T),][2:401,], digits = 2, row.names = F)

```

#### Top 400 most strongly related variables (absolute values) according to phylocor2

```{r, echo=FALSE, message=F, warning=F}

kable(res[order(abs(res$phylocor2), decreasing = T),][2:401,], digits = 2, row.names = F)

```


#### Top 400 greatest deviations of phylocor between the two methods

```{r, echo=FALSE, message=F, warning=F}

kable(res.i[order(abs(res.i$phylocor1 - res.i$phylocor2), decreasing = T),][1:400,], digits = 2, row.names = F)

```

<br>
<br>

***

## APPENDIX 2

### **Functions:**



```{r, eval=F}
phylomat <-solve(vcv.phylo(tree))  #REALLY TIME CONSUMING

# produce named vector of variable data to use for phyloCor analysis
getNamedVector <- function(var, data){
  x <- as.vector(as.numeric(data[,var]))
  names(x) <- data$species
  return(x)
}

# Produce new phylo.matrix for subset of species
subsetPhylomat <- function(spp, phylomat, match.dat = NULL){
  
  nsps <- length(spp) 
  vmat <- matrix(NA, nrow = nsps, ncol = nsps, dimnames = list(spp, spp))
  
  m.id <- cbind(rep(spp, times = nsps), rep(spp, each = nsps))
  
  if(is.null(match.dat)){
    if(all(spp %in% unlist(dimnames(phylomat)))){p.id <- m.id}else{
      stop("data species names do not match phylogeny tip names. correct or provide match.dat data.frame")}
  }else{
    p.id <- cbind(rep(match.dat$synonyms[match(spp, match.dat$species)], times = nsps), 
                  rep(match.dat$synonyms[match(spp, match.dat$species)], each = nsps))}
  
  vmat[m.id] <- phylomat[p.id]
  
  return(vmat)
}

phylo.mean <- function(x, phylomat){
  mean <-colSums(phylomat%*%x)/sum(phylomat)}

phylo.var <- function(x, mean, phylomat, nsps){
  var.x <-t(x-mean) %*% phylomat%*%(x-mean)/(nsps-1)
}


getPhyloCor <- function(x, y, phylomat, nsps){
  
  if(any(names(x) != names(y))){stop("vector species names mismatch")}
  if(dim(phylomat)[1] != dim(phylomat)[2]){stop("phylomat not square")}
  if(any(dimnames(phylomat)[[1]] != dimnames(phylomat)[[2]])){stop("phylomat dimnames mismatch")}
  if(any(names(x) != dimnames(phylomat)[[1]], names(x) != dimnames(phylomat)[[2]])){stop("x and phylomat name mismatch")}
  if(any(names(y) != dimnames(phylomat)[[1]], names(y) != dimnames(phylomat)[[2]])){stop("x and phylomat name mismatch")}
  
  
  mean.x <- phylo.mean(x, phylomat)
  mean.y <- phylo.mean(y, phylomat)
  
  var.x <- phylo.var(x, mean.x, phylomat, nsps = nsps)
  var.y <- phylo.var(y, mean.y, phylomat, nsps = nsps)
  
  cor.xy <- as.vector((t(x-mean.x) %*% phylomat%*%(y-mean.x)/(nsps-1))/sqrt(var.x*var.y))
  
  return(cor.xy)
}

comparePhyloCor <- function(x, data, phylomat, match.dat){

  var1 <- unlist(x[1])
  var2 <- unlist(x[2])
  
  data <- data[, c("species", "synonyms", var1, var2)] 
  data <- data[complete.cases(data),]
  
  spp <- data$species
  nsps <- length(spp)
  
  x <- getNamedVector(var1, data = data)
  y <- getNamedVector(var2, data = data)
  
# Std. correlation
  
  cor <- cor(x, y)
  

#METHOD 1 using phylogenetic relatedness matrix:
#----------------------------------------------------

sub.phymat <- subsetPhylomat(spp, phylomat, match.dat)

phylocor1 <- getPhyloCor(x, y, phylomat = sub.phymat, nsps = nsps)



################################################################################

#METHOD 2 extracting from a PGLS
#----------------------------------------------------
  
  cd <- comparative.data(phy = tree, data = data, names.col = "synonyms")
  result.pgls <- try(pgls(as.formula(paste(var1, "~", var2, sep = "")), data = cd), silent = T)

  if(class(result.pgls) == "try-error"){phylocor2 <- NA}else{
    t <- summary(result.pgls)$coefficients[var2,3]
    df <- as.vector(summary(result.pgls)$fstatistic["dendf"])
    phylocor2 <- sqrt((t*t)/((t*t)+df))*sign(summary(result.pgls)$coefficients[var2,1])
    }


return(data.frame(var1 = var1, var2 = var2, cor = cor, phylocor1 = phylocor1, 
                  phylocor2 = phylocor2, n = nsps))
}

```

***

<br>

### **Workflow:**


```{r, eval=F}

#load match data
load(file = "r data/match data/tree m.RData")
match.dat <- m$data

# Create wide dataset:
wide <- widenMaster(vars = unique(D0$var), species = unique(D0$species), 
                    master = D0, metadata = metadata)

# separate numeric variables
num.var <- metadata$master.vname[metadata$type %in% c("Int", "Con")]
num.dat <- wide[,c("species", names(wide)[names(wide) %in% num.var])]


# add synonym column to data 
num.dat$synonyms <- match.dat$species[match(wide$species, match.dat$species)]

# VARIABLES

## Create grid of unique variable combinations, calculate data availability for each and sort
var.grid <- calcTraitPairN(num.dat)
var.grid <- var.grid[var.grid$n > 30,]
var.grid <- var.grid[order(var.grid$n, decreasing = T),]

#Prepare phylogenetic relatedness matrix
load(file = "tree/tree.RData")

phylomat <-solve(vcv.phylo(tree))  #REALLY TIME CONSUMING

res <- NULL

for(i in c(1:dim(var.grid)[1])){
  
  res <- rbind(res, comparePhyloCor(var.grid[i,1:2], data = num.dat, 
               phylomat = phylomat, match.dat = match.dat))
}
```